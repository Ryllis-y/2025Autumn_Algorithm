# F 约会大作战-墨鱼版

### 题意简述

给定 $n$ 个 Toby 和 $n$ 个墨鱼。
第 $i$ 个 Toby 的魅力值为 $a_i$，要求对象的魅力值至少为 $p_i$；
第 $j$ 个墨鱼的魅力值为 $b_j$，要求对象的魅力值至少为 $q_j$。
当 Toby 和墨鱼互相满足对方的魅力值要求时，两者可以约会。
求最大能组成的约会配对数量（每只 Toby 或墨鱼最多参与一对）。

这是二分图最大匹配问题。
我们将 Toby 视为左侧集合 $U$，墨鱼视为右侧集合 $V$
如果 Toby $i$ 和 墨鱼 $j$ 满足条件（即 $a_i \ge q_j$ 且 $b_j \ge p_i$），则在 $U_i$ 和 $V_j$ 之间连一条边。
问题转化为求该二分图的最大匹配数。

---

### 解法一：匈牙利算法

#### 基本思路
匈牙利算法是解决二分图最大匹配的通用算法。
1.  **建图**：遍历所有可能的 Toby 和墨鱼组合。如果 Toby $i$ 的魅力值 $a_i$ 大于等于墨鱼 $j$ 的要求 $q_j$（代码中对应读取到 `p[j]`），且墨鱼 $j$ 的魅力值 $b_j$（代码中对应 `a[j]`）大于等于 Toby $i$ 的要求 $p_i$，则建立一条有向边 $i \to j$。
2.  **匹配**：遍历每一个 Toby，尝试为其寻找增广路（DFS）。如果在 DFS 过程中找到一个未被匹配的墨鱼，或者该墨鱼已匹配的 Toby 可以找到另一个墨鱼，则更新匹配关系，答案加一。

#### AC代码
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int MAXN = 1007;     // 节点数上限
const int MAXM = 50007;    // 边数上限

int n, cnt = 1;
// a[]存储魅力值，p[]存储要求值
// 1~n为Toby，n+1~2n为墨鱼
int a[MAXN], p[MAXN]; 

// 链式前向星建图
ll node[MAXN], edge[MAXM * 4], nxt[MAXM * 4];

// match[v] 记录右侧点 v 当前匹配的左侧点
// visit[v] 记录本次DFS中右侧点 v 是否被访问过
int match[MAXN], visit[MAXN];    

void addEdge(ll x, ll y){
    nxt[cnt] = node[x];
    node[x] = cnt;
    edge[cnt++] = y;
}

// 寻找增广路
int dfs(ll u){
    for (int e = node[u]; e; e = nxt[e]){
        int v = edge[e];
        if (visit[v]) continue;
        visit[v] = 1;
        // 如果v没有匹配，或者v的匹配对象能找到其他位置
        if (!match[v] || dfs(match[v])){
            match[v] = u;
            return 1;
        }
    }
    return 0;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> n;
    
    // 输入处理：将墨鱼的数据存放在下标 n+1 到 2n
    for (int i = 1; i <= n; i++) cin >> a[i];         // Toby 魅力
    for (int i = 1; i <= n; i++) cin >> p[i];         // Toby 要求
    for (int i = n + 1; i <= 2 * n; i++) cin >> a[i]; // 墨鱼 魅力 (题目中的b)
    for (int i = n + 1; i <= 2 * n; i++) cin >> p[i]; // 墨鱼 要求 (题目中的q)
    
    // 建图
    for (int i = 1; i <= n; i++) {
        for (int j = n + 1; j <= 2 * n; j++) {
            // 相互满足条件
            if (a[i] >= p[j] && a[j] >= p[i])
                addEdge(i, j);      
        }
    }
    
    int ans = 0;
    for (int u = 1; u <= n; u++) {
        memset(visit, 0, sizeof(visit)); // 每次寻找需重置访问标记
        ans += dfs(u);
    }
    cout << ans << endl;
    return 0;
}
```

#### 复杂度分析
*   **时间复杂度**：$O(V \cdot E)$ 遍历V个节点进行dfs，dfs每次最多遍历E条边
*   **空间复杂度**：$O(n^2)$，主要用于存储边。

---

### 解法二：Dinic算法

#### 基本思路
二分图匹配问题可以转化为最大流问题求解。
1.  **建立源汇点**：设置虚拟源点 $S=0$ 和虚拟汇点 $T=2n+1$。
2.  **建边**：
    *   从源点 $S$ 向每个 Toby ($1 \dots n$) 连一条容量为 1 的边。
    *   从每个墨鱼 ($n+1 \dots 2n$) 向汇点 $T$ 连一条容量为 1 的边。
    *   如果 Toby $i$ 和 墨鱼 $j$ 互相喜欢，则从 $i$ 向 $j$ 连一条容量为 1 的边。
3.  **求解**：该网络的最大流量即为最大匹配数。Dinic 算法通过分层图（Level Graph）多路增广，效率较高。

#### AC代码
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 807;      // 点数：400+400+源+汇
const int MAXM = 320007;   // 边数：n^2 + 2n，需考虑反向边
const int INF = 0x3f3f3f3f;

int n, cnt;
int a[MAXN], p[MAXN];
// Dinic所需数组
int node[MAXN], level[MAXN], cur[MAXN];
int edge[MAXM], cap[MAXM], nxt[MAXM];

void addEdge(int u, int v, int c) {
    edge[cnt] = v; cap[cnt] = c; nxt[cnt] = node[u]; node[u] = cnt++;
    edge[cnt] = u; cap[cnt] = 0; nxt[cnt] = node[v]; node[v] = cnt++;
}

// BFS构建分层图
bool bfs(int s, int t) {
    memset(level, -1, sizeof(level));
    queue<int> q;
    q.push(s);
    level[s] = 0;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int i = node[u]; i != -1; i = nxt[i]) {
            int v = edge[i];
            if (level[v] == -1 && cap[i] > 0) {
                level[v] = level[u] + 1;
                q.push(v);
            }
        }
    }
    return level[t] != -1;
}

// DFS多路增广
int dfs(int u, int t, int flow) {
    if (u == t) return flow;
    for (int& i = cur[u]; i != -1; i = nxt[i]) {
        int v = edge[i];
        if (level[v] == level[u] + 1 && cap[i] > 0) {
            int f = dfs(v, t, min(flow, cap[i]));
            if (f > 0) {
                cap[i] -= f;
                cap[i ^ 1] += f;
                return f;
            }
        }
    }
    return 0;
}

int dinic(int s, int t) {
    int mf = 0;
    while (bfs(s, t)) {
        memcpy(cur, node, sizeof(node)); // 当前弧优化
        while (int f = dfs(s, t, INF)) {
            mf += f;
        }
    }
    return mf;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    memset(node, -1, sizeof(node));
    cnt = 0; 
    cin >> n;
    
    // 输入复用相同数组，后n个为墨鱼数据
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1; i <= n; i++) cin >> p[i];
    for (int i = n + 1; i <= 2 * n; i++) cin >> a[i];
    for (int i = n + 1; i <= 2 * n; i++) cin >> p[i];
    
    int s = 0;          
    int t = 2 * n + 1;  
    
    // 源点 -> Toby
    for (int i = 1; i <= n; i++) {
        addEdge(s, i, 1);
    }

    // Toby -> 墨鱼
    for (int i = 1; i <= n; i++) {
        for (int j = n + 1; j <= 2 * n; j++) {
            if (a[i] >= p[j] && a[j] >= p[i])
                addEdge(i, j, 1);
        }
    }
    
    // 墨鱼 -> 汇点
    for (int j = n + 1; j <= 2 * n; j++) {
        addEdge(j, t, 1);
    }
    
    cout << dinic(s, t) << endl;
    return 0;
}
```

#### 复杂度分析
*   **时间复杂度**：$O(E\sqrt{V})$。除去源点和汇点外所有节点的流量进出容量限制都为 1，因此每条增广路都会消耗掉路径上的点 由根号分治可知最多进行$ \sqrt{V} $次Dinic循环。而每次dfs同样最多遍历E条边
*   **空间复杂度**：$O(V + E)$，需要存储图结构。

**分析**：

本题可以转化为**二分图最大匹配**问题：

1. **二分图结构明显**：
   - 左部节点：\( n \) 个 Toby
   - 右部节点：\( n \) 个墨鱼
   - 天然形成二分图的两部分



2. **一对一匹配限制**：
   - 每个 Toby 只能匹配最多一个墨鱼
   - 每个墨鱼只能匹配最多一个 Toby
   - 这正是二分图匹配的**基本约束**

3p. **目标一致**：
   - 求**最大匹配数** = 求最多能成的约会对数

**因此**，问题直接对应到：
- 建立二分图：满足上述条件的 Toby \( i \) 和墨鱼 \( j \) 连边
- 求该二分图的**最大匹配**
- 可用匈牙利算法（O(n³)）或网络流（O(n².⁵)）求解

**复杂度**：n ≤ 400，两种方法均可通过。