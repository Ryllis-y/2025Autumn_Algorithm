# C1-E 题解

## 题目要求
本题要求我们计算两个多项式的和，需要将同类项（即相同指数的项）合并，并按指数严格递增的顺序输出结果。


## 方法一：暴力枚举
### 思路及算法
最直观的思路是先收集所有不重复的指数，再对每个指数遍历两个多项式计算系数和，本质是通过枚举所有可能的指数实现同类项合并：

先将第一个多项式的所有指数存入列表，再遍历第二个多项式的指数，若未在列表中则加入，确保列表中仅包含所有出现过的指数（无重复）；
对每个收集到的指数，分别遍历两个多项式，累加所有相同指数对应的系数，得到该指数的总系数。

该方法无需依赖复杂数据结构，核心是通过二层遍历实现找同类项，属于纯暴力思路。（代码略过）



### 复杂度分析
- **时间复杂度**：\(O(n^2 + m^2 + nm + k\log k)\)，其中 \(k\) 为合并后非零项数。  
  核心耗时在于：收集不重复指数时，对第二个多项式的每个指数需遍历第一个多项式的 \(n\) 个指数（\(O(nm)\)）；计算系数和时，对每个指数需遍历两个多项式（\(O(k(n+m))\)）；排序耗时 \(O(k\log k)\)。
- **空间复杂度**：\(O(n+m)\)，主要用于存储所有不重复指数和结果项。

## 方法二：哈希表

### 思路及算法
多项式加法本质是指数（键）映射到系数（值）的键值对合并问题。其实C++的stl容器中封装了map，可以很轻易地实现此功能。但由于本题禁用C++，所以所以只能造轮子了。数据结构方面选择哈希表，可实现 \(O(1)\) 级别的增删改查操作。


### 代码
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct Node {
    long long exp;
    long long co;
    struct Node* next;  
} Node;

Node* createNode(long long exp, long long co) {
    Node* node = (Node*)malloc(sizeof(Node));
    node->exp = exp;
    node->co = co;
    node->next = NULL;
    return node;
}

int hash(long long exp, int size) {
    return (int)((exp % size + size) % size);
}

void insert(Node** table, long long exp, long long co, int size) {
    int index = hash(exp, size);
    Node* curr = table[index];

    while (curr) {
        if (curr->exp == exp) {
            curr->co += co;
            return;
        }
        curr = curr->next;
    }
    
    Node* newNode = createNode(exp, co);
    newNode->next = table[index];
    table[index] = newNode;
}

int compare(const void* a, const void* b) {
    Term* t1 = (Term*)a;
    Term* t2 = (Term*)b;
    return t1->exp > t2->exp ? 1 : -1;
}

// 封装多项式
typedef struct {
    long long co;
    long long exp;
} Term;

int main() {
    int t;
    scanf("%d", &t);
    while (t--) {
        int n, m;
        // 读取第一个多项式
        scanf("%d", &n);
        long long* a = (long long*)malloc(n * sizeof(long long));
        long long* A = (long long*)malloc(n * sizeof(long long));
        for (int i = 0; i < n; ++i) scanf("%lld", &a[i]);
        for (int i = 0; i < n; ++i) scanf("%lld", &A[i]);
        
        // 读取第二个多项式
        scanf("%d", &m);
        long long* b = (long long*)malloc(m * sizeof(long long));
        long long* B = (long long*)malloc(m * sizeof(long long));
        for (int i = 0; i < m; ++i) scanf("%lld", &b[i]);
        for (int i = 0; i < m; ++i) scanf("%lld", &B[i]);
        
        // 初始化哈希表（大小设为n+m，减少冲突）
        int hashSize = n + m;
        Node** table = (Node**)calloc(hashSize, sizeof(Node*));
        
        // 合并第一个多项式
        for (int i = 0; i < n; ++i) {
            insert(table, A[i], a[i], hashSize);
        }
        // 合并第二个多项式
        for (int i = 0; i < m; ++i) {
            insert(table, B[i], b[i], hashSize);
        }
        
        // 收集哈希表中所有项
        Term* result = (Term*)malloc((n + m) * sizeof(Term));
        int k = 0;
        for (int i = 0; i < hashSize; ++i) {
            Node* curr = table[i];
            while (curr) {
                result[k].co = curr->co;
                result[k].exp = curr->exp;
                ++k;
                curr = curr->next;
            }
        }
        
        // 按指数升序排序
        qsort(result, k, sizeof(Term), compare);
        
        // 输出结果
        printf("%d\n", k);
        for (int i = 0; i < k; ++i) printf("%lld ", result[i].co);
        printf("\n");
        for (int i = 0; i < k; ++i) printf("%lld ", result[i].exp);
        printf("\n");
        
        // 释放内存
        free(a); free(A); free(b); free(B); free(result);
        // 释放哈希表
        for (int i = 0; i < hashSize; ++i) {
            Node* curr = table[i];
            while (curr) {
                Node* temp = curr;
                curr = curr->next;
                free(temp);
            }
        }
        free(table);
    }
    return 0;
}
```

### 复杂度分析
- **时间复杂度**：\(O(n + m + k\log k)\)，其中 \(k\) 为合并后非零项数。插入哈希表耗时 \(O(n + m)\)（平均情况），排序耗时 \(O(k\log k)\)。（排序比较冗余）
- **空间复杂度**：\(O(n + m)\)，主要用于哈希表存储和结果数组。

## 方法三：双指针（利用有序性优化）
### 思路及算法
注意到方法一效率低的核心原因是未利用输入指数严格递增，遍历获得信息的效率低。由于两个多项式的指数均严格递增，可类比归并排序的“合并阶段”，用双指针实现线性时间合并：
1. **初始化指针**：维护两个指针 \(i\) 和 \(j\)，分别指向A数组和B数组当前索引，初始化为\(1\)。
2. **双指针遍历合并**：
   - 若 \(A[i] < B[j]\)：第一个多项式当前项指数更小，直接加入结果，\(i\) 指针后移；
   - 若 \(A[i] > B[j]\)：第二个多项式当前项指数更小，直接加入结果，\(j\) 指针后移；
   - 若 \(A[i] = B[j]\)：指数相同，系数相加后加入结果，\(i\) 和 \(j\) 同时后移；
3. **处理剩余项**：当一个多项式遍历完毕后，将另一个多项式的剩余项直接加入结果（因指数严格递增，剩余项均大于已合并项）。

### 代码
```c
#include <stdio.h>
#include <stdlib.h>

// 封装多项式中的项
typedef struct {
    long long co;  
    long long exp;    
} Term;

int main() {
    int t;
    scanf("%d", &t);
    while (t--) {
        int n, m;
        // 读取第一个多项式
        scanf("%d", &n);
        long long* a = (long long*)malloc(n * sizeof(long long));
        long long* A = (long long*)malloc(n * sizeof(long long));
        for (int i = 0; i < n; ++i) scanf("%lld", &a[i]);
        for (int i = 0; i < n; ++i) scanf("%lld", &A[i]);
        
        // 读取第二个多项式
        scanf("%d", &m);
        long long* b = (long long*)malloc(m * sizeof(long long));
        long long* B = (long long*)malloc(m * sizeof(long long));
        for (int i = 0; i < m; ++i) scanf("%lld", &b[i]);
        for (int i = 0; i < m; ++i) scanf("%lld", &B[i]);
        
        // 结果数组
        Term* res = (Term*)malloc((n + m) * sizeof(Term));
        int i = 0, j = 0, k = 0;  // i:A指针, j:B指针, k:结果指针
        
        while (i < n && j < m) {
            if (A[i] < B[j]) {
                res[k].co = a[i];
                res[k].exp = A[i];
                ++i;
            } else if (A[i] > B[j]) {
                res[k].co = b[j];
                res[k].exp = B[j];
                ++j;
            } else {
                // 同类项合并，题目保证系数和非零
                res[k].co = a[i] + b[j];
                res[k].exp = A[i];
                ++i;
                ++j;
            }
            ++k;
        }
        
        // 处理第一个多项式剩余项
        while (i < n) {
            res[k].co = a[i];
            res[k].exp = A[i];
            ++i;
            ++k;
        }
        // 处理第二个多项式剩余项
        while (j < m) {
            res[k].co = b[j];
            res[k].exp = B[j];
            ++j;
            ++k;
        }
        
        // 输出结果
        printf("%d\n", k);
        for (int p = 0; p < k; ++p) printf("%lld ", res[p].co);
        printf("\n");
        for (int p = 0; p < k; ++p) printf("%lld ", res[p].exp);
        printf("\n");
        
        // 释放内存
        free(a); free(A); free(b); free(B); free(res);
    }
    return 0;
}
```

### 复杂度分析
- **时间复杂度**：\(O(n + m)\)。双指针仅遍历两个多项式各一次，由于指针未回退，无冗余操作，且无需额外排序。
- **空间复杂度**：\(O(n + m)\)，主要用于存储结果数组。

