本题要求我们计算两个多项式的和，需要将同类项（即相同指数的项）合并，并按指数严格递增的顺序输出结果。

这个过程在数学中想必大家已经是非常熟悉了。但如果我们直接用数学上的过程来模拟，其实会遇到很多问题：首先，答该如何储存答案？如果直接简单地开一个答案数组，用索引值代表答案的幂的话肯定是行不通的，因为A_i和B_i最高可以到10^9,空间开销过大了；而如果边读边收集幂的情况的话，……
而如果在算法的角度思考，这其实处理的是键值对的合并问题：键值对其实就是一种映射关系，给定一个key（键）会指向唯一的value（值） （以下可以清晰易懂地介绍键值对的视角）……
在本题里我们就可以将多项式中每一项的幂理解为键、系数理解为值。每当读取一个项，若答案中未包含这个项的幂次的键，那就将这个幂次作为键添加进去，值初始化为这个项的系数；若已存在这个键，那么在答案中将这个键的所映射的值加上新的项的系数。
对于这样的逻辑过程，其实很自然地能想到我们之前学习的一种数据结构：哈希表。对于这种处理离散化数据的映射关系的问题效率很高，增删改查的时间复杂度都是O(n)，处理本问题的效率也是足够的高。其实在C++中有一个封装好的stl容器map，可以很轻松地实现键值对的增删改查，大概也是本题不让用C++的原因吧。
但是如果使用哈希表，其实没有使用到本题的一个条件，就是读入的两个多项式的幂次也是有序的。为什么这个条件是可以利用的呢？那就是我们可以维护两个指针。其实这个过程跟之前学的归并排序算法很相似，在合并两个有序数组的时候，根据左右两数组当前位置的元素的大小情况移动指针。看起来也是在遍历两个数组，但由于指针从来没有回退，所以时间复杂度只有O(n+m)。那么本题的处理也是这样，接下来可以参考代码。