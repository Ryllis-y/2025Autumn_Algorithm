# G - ALyCE与堆

## 问题描述
给定两个长度均为`N`的数组`A`和`B`，我们需要从所有可能的组合`A[i] + B[j]`（共`N²`个结果）中，筛选出最小的`N`个和并按要求输出。


## 思考与解法推导

### 初步分析
最直接的思路是生成所有`N²`个和，排序后取前`N`个。但无论时间（排序`O(N²logN)`）还是空间（存储`N²`个元素）都无法承受。


### 关键点：高效筛选最小的N个值
因此很自然地想到使用贪心策略——每次选出当前最小的元素，重复`N`次即可,不必把`N²`个组合情况全部计算出来。但贪心的关键在于两个问题：
- 如何快速找到当前最小的和？
- 找到后，如何高效确定下一个可能的最小和？

这两个问题的解决，都依赖于数据的“有序性”。因此我们自然需要对数组`A`和`B`进行升序排序。

但仅仅是这样的数据预处理并不能得到很清晰的比较关系，因为每次选择后可能衍生多个新候选（如选A[0]+B[0]后，下一个最小元素的候选为A[0]+B[1]和A[1]+B[0]，如果我们选择了其中一个（比如`A[0] + B[1]`），那么再下一个候选又可能是`A[0] + B[2]`或`A[1] + B[1]`…… 以此类推），若不约束，候选数量会快速增长，依然难以解决问题。


###  分组构造单调性
为了约束候选范围，我们可以进一步预处理数据，按`B`的索引`j`将所有和分为`N`个“分组”：
- 第`0`组：`A[0]+B[0]`、`A[1]+B[0]`、`A[2]+B[0]`、…、`A[N-1]+B[0]`
- 第`1`组：`A[0]+B[1]`、`A[1]+B[1]`、`A[2]+B[1]`、…、`A[N-1]+B[1]`
- ……
- 第`j`组：`A[0]+B[j]`、`A[1]+B[j]`、…、`A[N-1]+B[j]`

由于`A`已经过升序排序，每组内部的和具有严格的单调性：对于第`j`组，随着`i`的增大，`A[i]`增大而`B[j]`不变，因此`A[i] + B[j]`必然递增（即`A[i] + B[j] ≤ A[i+1] + B[j]`）。

这种“组内单调性”意味着**每个组内的元素是按顺序递增的**。因此，当我们从第`j`组中选出`A[i] + B[j]`作为当前最小和后，该组的下一个候选只能是`A[i+1] + B[j]`，而不需要考虑其他跳跃性的索引。这就严格约束了候选的产生，避免了候选分支的膨胀。


有了分组和组内单调性，我们可以用“小根堆”（优先队列）来管理候选和：
- **初始化堆**：将每个分组的第一个元素（即`A[0] + B[j]`，`j`从`0`到`N-1`）放入堆中。此时堆中存储的是每个分组的最小元素，堆顶就是全局最小的和。
- **迭代筛选**：
  1. 取出堆顶元素（当前最小的和），将其加入结果列表。
  2. 若该元素来自第`j`组的索引`i`，且`i+1 < N`，则将该组的下一个元素`A[i+1] + B[j]`放入堆中（利用组内单调性，它是该组的下一个候选）。
  3. 重复上述步骤`N`次，即可得到最小的`N`个和。

## 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

    int N;
    cin >> N;

    vector<long long> A(N), B(N);
    for (int i = 0; i < N; i++) cin >> A[i];
    for (int i = 0; i < N; i++) cin >> B[i];

    // 对数组A和B排序
    sort(A.begin(), A.end());
    sort(B.begin(), B.end());

    // 小根堆存储三元组，用于维护当前最小候选
    priority_queue<tuple<long long, int, int>, 
                   vector<tuple<long long, int, int>>, 
                   greater<>> pq;

    // 初始化堆：将每个分组j的第一个元素入堆
    for (int j = 0; j < N; j++) {
        pq.emplace(A[0] + B[j], 0, j);
    }

    vector<long long> result;
    for (int k = 0; k < N; k++) {
        auto [sum, i, j] = pq.top();  // 取出当前最小和
        pq.pop();
        result.push_back(sum);

        // 若当前组还有下一个元素，将其入堆作为新候选
        if (i + 1 < N) {
            pq.emplace(A[i + 1] + B[j], i + 1, j);
        }
    }

    for (int k = 0; k < N; k++) {
        cout << result[k] << (k == N - 1 ? "\n" : " ");
    }

    return 0;
}
```


### 复杂度分析
- **时间复杂度**：`O(NlogN)`。排序`A`和`B`占`O(NlogN)`，堆操作（`N`次入堆和出堆）占`O(NlogN)`。
- **空间复杂度**：`O(N)`。存储数组`A`、`B`、结果及堆（堆大小不超过`N`）。
