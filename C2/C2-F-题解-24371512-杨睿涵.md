# F - wiki数星星

## 问题描述
有一个初始为 \( f(x) = 0 \) 的函数，经过 \( Q \) 次操作，操作分为两种：
- 更新操作：给定 \( a, b \)，令 \( f(x) = f(x) + |x - a| + b \)。
- 查询操作：输出使 \( f(x) \) 最小的整数 \( x \) 以及最小值 \( f(x) \)（若有多个最小 \( x \)，选最小的那个）。


## 解法思路

### 数学转化
首先分析函数 \( f(x) \) 的构成。每次更新操作会给函数增加一项 \( |x - a| + b \)，因此经过多次操作后，\( f(x) \) 可表示为：  
\( f(x) = \sum (|x - a_i|) + \sum b_i \)  

其中 \( \sum b_i \) 是所有 \( b \) 的累加和（记为 \( sb \)），它是一个与 \( x \) 无关的常数。因此，求 \( f(x) \) 的最小值等价于求 \( \sum |x - a_i| \) 的最小值，再加上 \( sb \) 即可。


由绝对值的几何意义，问题可化为：在数轴上有若干点 \( a_1, a_2, ..., a_k \)，找到一点 \( x \) 使得所有点到 \( x \) 的距离之和最小。 
 
这个问题的结论是：**当 \( x \) 为这些点的中位数时，距离和最小**。  
- 若点的数量为奇数，中位数是排序后中间的那个点；  
- 若为偶数，所有位于中间两个点之间的 \( x \) 都能使距离和最小，按题意选择最小的 \( x \)（即左端点）。


### 数据结构：用堆维护中位数
为了高效维护中位数并计算距离和，我们需要一种能动态插入元素并快速找到中位数的结构。这里采用两个堆的组合：
- **大根堆 \( l \)**：存储较小的一半元素（包括中位数），堆顶为当前中位数。  
- **小根堆 \( r \)**：存储较大的一半元素，堆顶为右侧最小的元素。  

通过调整两个堆的大小，保证：  
- \( l \) 的大小 = \( r \) 的大小（偶数个元素时），或 \( l \) 的大小 = \( r \) 的大小 + 1（奇数个元素时）。  
这样 \( l \) 的堆顶始终是我们需要的中位数。


### 距离和的计算
设 \( l \) 中有 \( ls \) 个元素，总和为 \( sl \)；\( r \) 中有 \( rs \) 个元素，总和为 \( sr \)，中位数为 \( mid \)。  
- 对于 \( l \) 中的元素：每个 \( a_i \leq mid \)，距离和为 \( mid - a_i \)，总和为 \( mid \times ls - sl \)。  
- 对于 \( r \) 中的元素：每个 \( a_i \geq mid \)，距离和为 \( a_i - mid \)，总和为 \( sr - mid \times rs \)。  

因此，总距离和为 \( (mid \times ls - sl) + (sr - mid \times rs) \)，加上 \( sb \) 即为 \( f(x) \) 的最小值。


## 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

priority_queue<ll> l;  // 大根堆，存储左半部分（包括中位数）
priority_queue<ll, vector<ll>, greater<ll>> r;  // 小根堆，存储右半部分
ll sl = 0, sr = 0, sb = 0;  // sl：l中元素和，sr：r中元素和，sb：所有b的和

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    
    int Q;
    cin >> Q;
    
    while (Q--) {
        int op;
        cin >> op;
        if (op == 1) {
            ll a, b;
            cin >> a >> b;
            sb += b;  // 累加b的值

            // 将a插入到合适的堆
            if (l.empty() || a <= l.top()) {
                l.push(a);
                sl += a;
            } else {
                r.push(a);
                sr += a;
            }

            // 调整堆的大小，保证l的大小等于r或比r大1
            if (l.size() > r.size() + 1) {
                ll t = l.top();
                l.pop();
                sl -= t;
                r.push(t);
                sr += t;
            } else if (r.size() > l.size()) {
                ll t = r.top();
                r.pop();
                sr -= t;
                l.push(t);
                sl += t;
            }
        } else {
            ll mid = l.top();  // l的堆顶即为使f(x)最小的x
            ll ls = l.size(), rs = r.size();
            // 计算最小值
            ll ans = mid * ls - sl + sr - mid * rs + sb;
            cout << mid << " " << ans << "\n";
        }
    }
    
    return 0;
}
```


## 复杂度分析
- **时间复杂度**：\( O(Q \log Q) \)。每次更新操作中，堆的插入和调整为 \( O(\log Q) \)；查询操作仅需访问堆顶和计算为 \( O(1) \)，总复杂度由 \( Q \) 次更新决定。
- **空间复杂度**：\( O(Q) \)。两个堆最多存储 \( Q \) 个 \( a \) 的值。