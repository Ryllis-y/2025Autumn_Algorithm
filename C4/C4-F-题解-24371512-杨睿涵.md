# F-Yuki 分硬币

### 题意简述

初始有$ S $枚硬币在一个存钱罐里。每次可以选一个数量$ Q >= 2 $的存钱罐，从中取出$ a $枚（$ 1 <= a < Q $）放入一个新罐子，并获得$ a * (Q-a) $ 的快乐值。求获得至少$ M $点快乐值所需的最少操作次数。

### 错误的贪心思路

看到“最少次数”和“最大化收益”这样的问题，第一反应往往是贪心。一个非常自然的贪心策略是：**每一步都做能让当前快乐值增加最多的选择，即局部最优决策**。

具体来说，对于一个数量为$ Q $的罐子，要让$ a * (Q-a) $最大，$ a $ 应该取$ floor(Q/2)$。所以，贪心策略就是在每一步，选择当前最大的那个存钱罐，并将它近乎平分。可以通过一个大根堆来维护，每次操作后再把它分出来的两堆硬币压回堆。

这个策略看起来很合理，但其实可以举出反例：
`S = 8, M = 21`

**贪心策略：**
1.  **第1步**：初始只有一个 $ {8} $。当前最优选择是拆成 ${4, 4} $，获得 $ 4 * 4 = 16 $ 快乐值。
    *   当前状态: $ {4, 4}$，总快乐值 `16`。$ 16 < 21 $，继续。
2.  **第2步**：现在有 $ {4, 4} $。选择其中一个$ 4 $拆成 $ {2, 2} $，获得 $ 2 * 2 = 4 $ 快乐值。
    *   当前状态: $ {4, 2, 2} $，总快乐值$ 16 + 4 = 20 $。$ 20 < 21 $，继续。
3.  **第3步**：现在有$ {4, 2, 2} $。选择$ 4 $拆成 $ {2, 2} $，获得$ 2 * 2 = 4 $ 快乐值。
    *   当前状态:$ {2, 2, 2, 2} $，总快乐值$ 20 + 4 = 24 $。$ 24 >= 21 $，停止。

贪心算法认为需要 **3** 次操作。

**最优路径：**
然而最优解是 **2** 次。我们可以通过 $ 8 -> {5, 3} $ (获得15快乐)，再 $ 5 -> {2, 3}$ (获得6快乐)，最终状态为 ${3, 3, 2} $，总快乐值为 $ 15 + 6 = 21 $。仅用2步就达到了目标。

反例确实不容易发现，如果时间够的话可以写对拍验证一下


### 正确的解法

既然贪心不行，我们需要转换思路。



1.  **单步操作的组合学意义**：
    重新观察题目：当一个数量为$ Q $ 的罐子被拆分为 $ a $ 和$ Q-a $两份时，获得的快乐值 $ a * (Q-a) $ 。根据计数乘法原理，这个值恰好等于“从$ a $堆中任选一枚硬币，同时从$ Q-a $堆中任选一枚硬币”所能组成的配对数量。
    换言之，**单次操作获得的快乐值，精确地等于在这次操作中被新分离的硬币配对的数量**。

2.  **总快乐值的等价转换**：
    由于总快乐值是所有单步操作快乐值的累加，所以它等价于整个过程中被分离开的硬币配对的总数。这意味着，总快乐值与具体的拆分顺序和路径无关，只与最终的局面有关。

3.  **通用公式**：
    基于此，我们可以从最终状态直接计算总快乐值。对于 $ S $枚硬币，总配对数为 $ C(S, 2) $。如果最终分成了 $ p_1, p_2, ... $ 等若干堆，那么还“在一起”的配对数就是 $ Σ C(p_i, 2) $。因此，总快乐值（即被分开的配对数）为：
    总快乐值 = $ C(S, 2) - Σ C(pᵢ, 2) $


#### 思路转换

我们的问题是“最少操作次数 $ k $”。这等价于寻找一个最小的$ k $，使得通过$ k $次操作可以达到的**最大快乐值** $ MaxH(k) $ 不小于$ M $。

$ k $ 次操作会产生$ k+1 $个存钱罐。要使$ MaxH(k) $ 最大，根据我们推导出的公式，我们需要让 $ Σ C(pᵢ, 2) $ 最小。要让平方和（$ C(p,2) $ 经过换元可以等价于 $ p²/2 $）最小，由基本不等式可知，各个 $ p_i $ 的值需要尽可能地平均。

因此$ MaxH(k) $的值可以通过将$ S $枚硬币尽可能平均地分到 $ k+1 $个罐子中来计算。

#### 二分答案

所以本题实际上转化为了：对于一个给定的$ k $，我们可以直接计算当前情形下能得到的最大快乐值，由此验证能否在k次划分中达到$ M $，然后找到满足条件的最小的那个$ k $。但是注意到$ MaxH(k) $这个函数有一种单调性：操作次数$ k $恰好能达到M的标准， 那么对于任何$ k' > k $ 也能满足， 而对于$ k'' < k $ 则都不能满足。

对于一个单调的函数，在$ MaxH(k) >= M $时最小化$ k $，可以考虑使用二分答案。


#### AC代码

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

// 计算 C(n, 2) = n * (n - 1) / 2
ll cb2(ll n) {
    if (n < 2) {
        return 0;
    }
    return n * (n - 1) / 2;
}

// 检查 k 次操作是否能获得至少 M 的快乐值
bool check(ll k, ll S, ll M) {
    if (k == 0) {
        return M == 0;
    }
    // k 次操作会产生 k+1 个存钱罐
    ll num_piles = k + 1;
    
    // 将 S 个硬币尽可能平均地分到 num_piles 个存钱罐中
    ll base_size = S / num_piles;
    ll remainder = S % num_piles;

    // 有 remainder 个存钱罐的大小为 base_size + 1
    // 有 num_piles - remainder 个存钱罐的大小为 base_size

    // 计算最终状态下，还留在同一个存钱罐里的配对总数
    ll sum_of_remaining_pairs = remainder * cb2(base_size + 1) + (num_piles - remainder) * cb2(base_size);

    // 理论最大快乐值
    ll max_total_happiness = cb2(S);

    // k 次操作能达到的最大快乐值
    ll k_max_happiness = max_total_happiness - sum_of_remaining_pairs;

    return k_max_happiness >= M;
}

int main() {

    ll S, M;
    cin >> S >> M;

    // 如果 M 大于理论最大值，则无解
    if (M > cb2(S)) {
        cout << -1 << endl;
        return 0;
    }

    // 二分答案
    ll l = 0, r = S - 1;
    ll ans = -1;

    while (l <= r) {
        ll mid = l + (r - l) / 2;
        if (check(mid, S, M)) {
            ans = mid;
            r = mid - 1;
        } else {
            l = mid + 1;
        }
    }

    cout << ans << endl;

    return 0;
}




```
### 复杂度分析

*   **时间复杂度**：`O(log S)`。主要由二分查找决定，每次 `check` 函数为 `O(1)`。
*   **空间复杂度**：`O(1)`。只使用了常数级别的额外空间。
