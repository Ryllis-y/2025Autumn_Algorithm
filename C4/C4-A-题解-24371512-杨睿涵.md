# A-Yuki 的连通块

### 题意简述

给定一个包含 `n` 个点和 `m` 条边的无向图，求该无向图中有多少个不同的连通块。

### 等价描述

设图为 `G = (V, E)`，即求解图 `G` 中连通分量的数量。

---

### 解法一：DFS

#### 基本思路
建完图后遍历每一个节点，若未访问过，则开始进行深度优先搜索（DFS），可以遍历到该顶点所在连通分量的所有顶点。我们记录访问过的顶点，每当遇到一个未被访问的顶点时，就意味着发现了一个新的连通分量，此时我们对该连通分量进行一次完整的 DFS 遍历，并将连通分量计数加一。BFS原理类似。



#### AC代码
```cpp
#include <bits/stdc++.h> 
using namespace std;     

const int MAXN = 1e6 + 5;
const int MAXM = 1e6 + 5;

int n, m;
int node[MAXN], edge[MAXM * 2], nxt[MAXM * 2];
//链式前向星建图
int idx;
bool visit[MAXN];

void addEdge(int u, int v) {
    edge[idx] = v;
    nxt[idx] = node[u];
    node[u] = idx++;
}

void dfs(int u) {
    visit[u] = true;
    for (int e = node[u]; e; e = nxt[e]) {
        int v = edge[e];
        if (!visit[v]) {
            dfs(v);
        }
    }
}

int main() {
    ios::sync_with_stdio(false); 
    cin.tie(NULL);

    cin >> n >> m;

    idx = 1; 

    for (int i = 0; i < m; ++i) {
        int u, v;
        cin >> u >> v;
        addEdge(u, v);
        addEdge(v, u); // 无向图建两条边
    }

    int cnt = 0;
    for (int i = 1; i <= n; ++i) {
        if (!visit[i]) {
            dfs(i);
            cnt++;
        }
    }

    cout << cnt << endl;

    return 0;
}
```


#### 复杂度分析
*   **时间复杂度**：`O(N + M)`， 建图开销` O(M) `, 遍历图时每个节点均只遍历一次， 开销` O(N) `。
*   **空间复杂度**：`O(N + M)`, 储存链式前向星的相关数组。

---

### 解法二：并查集 

#### 基本思路
并查集是处理不相交集合合并与查询问题的数据结构，与本题非常契合。我们将每个顶点初始化为一个独立的集合。对于图中的每条边 `(u, v)`，我们将 `u` 和 `v` 所在的集合进行合并。处理完所有边后，剩余的独立集合数量就是连通分量的数量。


#### AC代码
```cpp
#include <bits/stdc++.h> 
using namespace std;    

const int MAXN = 1e6 + 7;
int parent[MAXN];
int n, m;

int find(int x) {
    if (parent[x] != x) {
        parent[x] = find(parent[x]);
    }
    return parent[x];
}

void unite(int x, int y) {
    x = find(x);
    y = find(y);
    if (x != y) {
        parent[y] = x;
    }
}

int main() {
    ios::sync_with_stdio(false); 
    cin.tie(NULL);

    cin >> n >> m;

    for (int i = 1; i <= n; i++) {
        parent[i] = i;
    }
    
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        unite(u, v);  
    }

    int cnt = 0;
    for (int i = 1; i <= n; i++) {
        if (parent[i] == i) {
            cnt++;
        }
    }
    cout << cnt << endl;
    
    return 0;
}
```
#### 复杂度分析
*   **时间复杂度**：`O(N + M*α(N))`，初始化开销` O(N) `, M次`unite`开销为` O(M*α(N)) ` 总体可近似为` O(N + M) `。
*   **空间复杂度**：`O(N)`， 主要用于储存parent数组。