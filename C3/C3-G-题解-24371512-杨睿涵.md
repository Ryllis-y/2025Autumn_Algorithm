# G - 最优二叉搜索树

## 问题描述

给定有序键值集合 $\{1, 2, \ldots, n\}$ 和对应的访问概率 $p_1, p_2, \ldots, p_n$，构建一棵二叉搜索树，使得代价 $\sum_{i=1}^n (d_i + 1)p_i$ 最小，其中 $d_i$ 是节点 $i$ 的深度。需要输出最小代价和对应的树结构。

## 问题分析

### 从二叉树结构入手

二叉搜索树的结构特性是：**任何一棵 BST 都由根节点、左子树、右子树三部分组成**。基于这个结构特点，我们可以对问题进行分解

构建 BST 的过程为：

1. **选择根节点**
2. **构建左子树**
3. **构建右子树**

因此可以很自然地想到 先枚举根结点，再递归计算左右子树的思路

### 子问题定义

由于二叉搜索树必须保持**键值的有序性**，任何子树都对应一个**连续的键值区间**。这种结构约束使得我们可以用区间 $[i,j]$ 来刻画每个子问题：构建区间 $i$ 到 $j$ 的最优 BST

基于上述的分析，定义子问题：

$dp[i][j]$ = 区间 $[i,j]$ 构建 BST 的最小代价

**边界情况**：

- 当 $i > j$ 时：空树，代价为 $0$
- 当 $i = j$ 时：单节点树，代价为 $p_i$

### 计算分析

当选择 $k$ 为根节点时：

- **根节点代价**：$p_k$（深度为 0，比较 1 次）
- **左子树代价**：$dp[i][k-1]$ + 所有左子树节点深度增加 1 的代价
- **右子树代价**：$dp[k+1][j]$ + 所有右子树节点深度增加 1 的代价

**深度增加代价**：所有子树节点深度+1，总代价增加 $\sum_{t=i}^{j} p_t - p_k$

### 状态转移方程

综合以上分析，得到状态转移方程：

$$dp[i][j] = \min_{k=i}^{j} \left( dp[i][k-1] + dp[k+1][j] + \sum_{t=i}^{j} p_t \right)$$

其中：

- $dp[i][k-1]$表示左子树原始代价
- $dp[k+1][j]$表示右子树原始代价
- $\sum_{t=i}^{j} p_t$表示根节点代价 $p_k$ + 所有子树节点深度+1 的代价增量

## 合理性证明

### 最优子结构

**结论**：最优 BST 的左右子树必须分别是相应区间的最优 BST。

**证明**：
设 $T$ 是区间 $[i,j]$ 的最优 BST，根节点为 $k$，左右子树为 $T_L$ 和 $T_R$。

假设 $T_L$ 不是区间 $[i,k-1]$ 的最优 BST，则存在更优的 $T_L'$ 满足 $cost(T_L') < cost(T_L)$。

构造新树 $T'$：用 $T_L'$ 替换 $T_L$，保持根节点 $k$ 和右子树 $T_R$ 不变

则：
$$cost(T') = cost(T_L') + cost(T_R) + \sum_{t=i}^{j} p_t < cost(T_L) + cost(T_R) + \sum_{t=i}^{j} p_t = cost(T)$$

这与 $T$ 是最优 BST 矛盾。同理可证右子树

### 无后效性

**结论**：区间 $[i,j]$ 的 BST 代价只取决于该区间内的值。

**证明**：
由于 BST 的性质，区间 $[i,j]$ 内的树结构完全独立：

- 子树必须包含连续的键值区间
- 节点深度由区间内的树结构唯一确定
- 代价计算只依赖于节点深度和对应概率

因此，子问题的解是自包含的，可以独立求解。

## 递归解法（记忆化搜索）

```cpp
#include <bits/stdc++.h>
using namespace std;
const int INF = 0x3f3f3f3f;
int p[505], n;
int memo[505][505], root[505][505];
int prefix[505];

int dfs(int l, int r) {
    if (l > r) return 0;
    if (l == r) {
        root[l][r] = l;
        return p[l];
    }
    if (memo[l][r] != -1) return memo[l][r];

    int res = INF, best_root = -1;
    // 枚举根节点
    for (int k = l; k <= r; k++) {
        // 递归求解左右子树
        int left_cost = dfs(l, k-1);
        int right_cost = dfs(k+1, r);
        // 计算总代价
        int total = left_cost + right_cost + prefix[r] - prefix[l-1];

        if (total < res) {
            res = total;
            best_root = k;
        }
    }

    root[l][r] = best_root;
    return memo[l][r] = res;
}

void build_tree(int l, int r, int parent, bool is_left, int lchild[], int rchild[]) {
    if (l > r) return;

    int rt = root[l][r];
    if (parent != -1) {
        if (is_left) lchild[parent] = rt;
        else rchild[parent] = rt;
    }

    // 递归构建左右子树
    build_tree(l, rt-1, rt, true, lchild, rchild);
    build_tree(rt+1, r, rt, false, lchild, rchild);
}
```

## 递推解法

```cpp
#include <bits/stdc++.h>
using namespace std;
const int INF = 0x3f3f3f3f;
int p[505], n;
int dp[505][505], root[505][505];
int lchild[505], rchild[505], prefix[505];

void build(int l, int r, int parent, bool is_left) {
    if (l > r) return;

    int rt = root[l][r];
    if (parent != -1) {
        if (is_left) lchild[parent] = rt;
        else rchild[parent] = rt;
    }

    build(l, rt - 1, rt, true);
    build(rt + 1, r, rt, false);
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> p[i];
        //前缀和预处理
        prefix[i] = prefix[i - 1] + p[i];
        // 对应递归中的base case 单节点树根节点就是自己，代价为p[i]
        dp[i][i] = p[i];
        root[i][i] = i;
    }
    // 注意循环的顺序 先分析状态的依赖关系再写
    for (int i = n; i >= 1; i--) {
        for (int j = i + 1; j <= n; j++) {
            dp[i][j] = INF;
            // 枚举根结点
            for (int k = i; k <= j; k++) {
                int left_cost = (k > i) ? dp[i][k - 1] : 0;
                int right_cost = (k < j) ? dp[k + 1][j] : 0;
                int total = left_cost + right_cost + prefix[j] - prefix[i - 1];
                // 若成功更新最小值，则也将这个区间上的根结点记录为当前枚举的根结点
                if (total < dp[i][j]) {
                    dp[i][j] = total;
                    root[i][j] = k;
                }
            }
        }
    }

    // 构建树结构
    memset(lchild, -1, sizeof(lchild));
    memset(rchild, -1, sizeof(rchild));
    build(1, n, -1, false);

    cout << dp[1][n] << endl;
    for (int i = 1; i <= n; i++) {
        cout << lchild[i] << " " << rchild[i] << endl;
    }

    return 0;
}
```


## 复杂度分析

- **时间复杂度**：$O(n^3)$。dp 表共有 $O(n^2)$ 个状态，每个状态的枚举代价为 $O(n)$
- **空间复杂度**：$O(n^2)$。存储 DP 表和根节点信息


# 一个优化枚举的彩蛋


## 1. 四边形不等式定义

对于定义在整数域上的函数 $w(i,j)$，若对任意 $i \leq i' \leq j \leq j'$ 满足：
$$w(i,j) + w(i',j') \leq w(i,j') + w(i',j)$$
即"包含和" ≤ "交叉和"
则称 $w$ 满足四边形不等式。



## 2. 证明 $w(i,j) = \sum_{k=i}^j p_k$ 满足四边形不等式

**证明**：
对于 $i \leq i' \leq j \leq j'$，有：
- 左边：$w(i,j) + w(i',j') = \sum_{k=i}^j p_k + \sum_{k=i'}^{j'} p_k$
- 右边：$w(i,j') + w(i',j) = \sum_{k=i}^{j'} p_k + \sum_{k=i'}^j p_k$

两式相减：
$$[w(i,j') + w(i',j)] - [w(i,j) + w(i',j')] = \sum_{k=j+1}^{j'} p_k + \sum_{k=i}^{i'-1} p_k \geq 0$$

因此 $w(i,j) + w(i',j') \leq w(i,j') + w(i',j)$，等号当 $i=i'$ 或 $j=j'$ 时成立。

**单调性**：显然 $w(i,j)$ 关于 $i,j$ 单调不减。

## 3. 证明 $dp[i][j]$ 满足四边形不等式

**定理**：若 $w(i,j)$ 满足四边形不等式且 $dp[i][j]$ 由以下递推定义：
$$dp[i][j] = \min_{i \leq k \leq j} \{ dp[i][k-1] + dp[k+1][j] \} + w(i,j)$$
则 $dp[i][j]$ 也满足四边形不等式。

**证明思路**：
1. 基础情况：当 $j-i \leq 1$ 时直接验证
2. 归纳步骤：利用 $w(i,j)$ 的四边形不等式性质和最优决策的单调性
3. 最终证得对任意 $i \leq i' \leq j \leq j'$：
   $$dp[i,j] + dp[i',j'] \leq dp[i,j'] + dp[i',j]$$

## 4. 证明决策单调性：
$root[i][j-1] \leq root[i][j] \leq root[i+1][j]$

**证明**：
设 $root[i][j] = k$ 是区间 $[i,j]$ 的最优根节点。

**第一部分**：证明 $root[i][j-1] \leq root[i][j]$

假设存在 $k' > k$ 是 $[i,j-1]$ 的最优根，考虑在 $[i,j]$ 中以 $k'$ 为根的代价：
- 这会导致 $[i,j]$ 的根节点选择偏右，与 $k$ 的最优性矛盾
- 由 $dp[i][j]$ 的四边形不等式性质可严格证明

**第二部分**：证明 $root[i][j] \leq root[i+1][j]$

同理，假设存在 $k' < k$ 是 $[i+1,j]$ 的最优根，考虑在 $[i,j]$ 中以 $k'$ 为根的代价，与最优性矛盾。

**综上**：$root[i][j-1] \leq root[i][j] \leq root[i+1][j]$

### 优化效果
每个区间枚举 $O(1)$ 个候选（平均），总复杂度 $O(n^2)$

## 优化后的算法实现

```cpp
// 使用四边形不等式优化
for (int len = 2; len <= n; len++) {
    for (int i = 1; i + len - 1 <= n; i++) {
        int j = i + len - 1;
        dp[i][j] = INF;
        
        // 关键优化：利用决策单调性
        int left_bound = root[i][j-1];
        int right_bound = root[i+1][j];
        
        for (int k = left_bound; k <= right_bound; k++) {
            int left_cost = (k > i) ? dp[i][k-1] : 0;
            int right_cost = (k < j) ? dp[k+1][j] : 0;
            int total = left_cost + right_cost + prefix[j] - prefix[i-1];
            
            if (total < dp[i][j]) {
                dp[i][j] = total;
                root[i][j] = k;
            }
        }
    }
}
```

<del>其实完美利用了OBST问题的root数组对不对 这算不算是一种hint呢<del>
